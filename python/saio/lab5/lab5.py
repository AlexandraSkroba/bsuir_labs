# Задача о наидлиннейшем пути из заданной вершины в
# заданную вершину в направленном графе без контуров

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# Неориентированным графом называется упорядоченная пара множеств G = (V,E), V — это конечное непустое множество, элементы
# которого называются вершинами, E — множество неупорядоченных пар различных вершин.
# При этом неупорядоченные пары из множества E называются ребрами графа G.
# Ребро неориентированного графа — это неупорядоченная пара различных вершин.

# Ориентировать ребро e — значит указать какая из двух концевых вершин ребра e первая, а какая вторая.
# При этом ориентированное ребро называется дугой, первая вершина дуги называется ее началом,а вторая вершина — ее концом.

# Если задать ориентацию каждому ребру неориентированного графа, то получится направленный граф.
# В направленном графе маршрут — это чередующаяся последовательность вершин и дуг,
# где каждая дуга направлена от предыдущей вершины к следующей.

# Открытый маршрут — начальная и конечная вершины не совпадают
# Замкнутый маршрут — совпадают

# Открытый маршрут, в котором нет повторяющихся дуг, называется цепью. В свою очередь, цепь, в которой нет
# повторяющихся вершин, называется путем.
# Замкнутый маршрут, в котором нет повторяющихся дуг, называется циклом. Цикл, в котором нет
# повторяющихся вершин, кроме крайних, называется контуром.
def longest_path_with_path(adj_matrix, start_vertex, end_vertex):
    num_vertices = len(adj_matrix)

    # Функция для вычисления топологической сортировки графа.
    # Вершины графа упорядочиваются последовательно, чтобы все дуги шли слева направо.
    def topological_sort():
        visited = [False] * num_vertices
        stack = []

        # Запускаем поиск в глубину из каждой непосещенной вершины.
        # Цель — вычисление порядка обхода вершин для топологической сортировки.
        def dfs(vertex):
            visited[vertex] = True
            for neighbor in range(num_vertices):
                if adj_matrix[vertex][neighbor] > 0 and not visited[neighbor]:
                    dfs(neighbor)
            stack.append(vertex)

        # Запускаем DFS для каждой вершины, если она ещё не посещена.
        for vertex in range(num_vertices):
            if not visited[vertex]:
                dfs(vertex)

        # Разворачиваем стек, чтобы получить топологическую сортировку.
        return stack[::-1]  # Результат - упорядоченные вершины.

    # Получаем вершины в топологическом порядке.
    topological_order = topological_sort()

    # Инициализируем массивы для хранения максимальных длин путей и предков для восстановления пути.
    max_lengths = [-float('inf')] * num_vertices
    predecessors = [-1] * num_vertices
    max_lengths[start_vertex] = 0  # Начальная вершина имеет длину 0, т.е. OPT(v_s) = 0.

    # Проходим по вершинам в топологическом порядке.
    # Для каждой вершины vi находим максимальный путь.
    for vertex in topological_order:
        for neighbor in range(num_vertices): # существует ли ребро (дуга) между двумя вершинами в графе
            if adj_matrix[vertex][neighbor] > 0:  # Если есть дуга из vertex в neighbor.
                # Обновляем максимальную длину пути до соседней вершины.
                # Применяем рекуррентное соотношение для вычисления максимальной длины пути.
                if max_lengths[neighbor] < max_lengths[vertex] + adj_matrix[vertex][neighbor]:
                    max_lengths[neighbor] = max_lengths[vertex] + adj_matrix[vertex][neighbor]
                    predecessors[neighbor] = vertex  # Запоминаем предшественника для восстановления пути.

    # Построим путь, начиная с конечной вершины и двигаясь к начальной через предшественников.
    path = [end_vertex]
    current_vertex = end_vertex
    while current_vertex != start_vertex:
        current_vertex = predecessors[current_vertex]
        path.append(current_vertex)

    path.reverse()  # Разворачиваем путь, чтобы он начинался с начальной вершины.

    # Возвращаем максимальную длину пути и сам путь.
    return max_lengths[end_vertex], path


def main():
    # Задан направленный граф G = (V,A) без контуров.
    # Задаём матрицу смежности графа.
    # Каждая дуга графа имеет целое неотрицательное значение длины.
    adjacent_matrix = np.array([
        [0, 1, 2, 6, 0, 0],
        [0, 0, 2, 6, 1, 0],
        [0, 0, 0, 2, 3, 0],
        [0, 0, 0, 0, 2, 1],
        [0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0]
    ])

    # Определяем начальную (s) и конечную (t) вершины.
    start_vertex = 0
    end_vertex = 5

    # Требуется определить достижима ли в графе G вершина t из вершины s и в случае положительного ответа найти
    # наидлиннейший (s, t)-путь. Длина пути — это сумма длин его дуг.

    # Вычисляем наидлиннейший путь и его длину.
    result_length, result_path = longest_path_with_path(adjacent_matrix, start_vertex, end_vertex)

    # Выводим результат.
    print("Наидлиннейший путь из вершины", start_vertex, "в вершину", end_vertex, ":", result_path)
    print("Длина пути:", result_length)

    # Визуализируем граф с помощью библиотеки NetworkX.
    G = nx.DiGraph(np.matrix(adjacent_matrix))
    nx.draw(G, with_labels=True, node_size=300, arrows=True)
    plt.show()


if __name__ == "__main__":
    main()
