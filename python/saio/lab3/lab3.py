import numpy as np
# Задача распределения ресурсов

# Необходимо распределить весь имеющийся ресурс между
# агентами так, чтобы максимизировать суммарную прибыль.

# Предполагается, что любому агенту можно передать
# любое целое количество ресурсов от 0 до Q единиц.

# Элемент матрицы
# A, стоящий в i-й строке и j-м столбце равен прибыли, которую мы получим
# от i-го агента, если отдадим ему j единиц ресурса.

# Матрица прибыли
A = np.array([
    [0, 1, 2, 3],
    [0, 0, 1, 2],
    [0, 2, 2, 3]
])

P, Q = A.shape[0], A.shape[1] - 1
print(P)
print(Q)

# Инициализация матриц B и C
B = np.zeros((P, Q+1), dtype=int) # Функция Беллмана cопоставляет число, равное максимальной прибыли, которую
                                        # можно получить, распределив q единиц ресурса между первыми p агентами.
C = np.zeros((P, Q+1), dtype=int) # Количество единиц ресурса, которое необходимо передать p-му
                                        # агенту, чтобы получить максимальную прибыль при распределении q единиц ресурса между первыми p агентами.

# Для нахождения значений функции Беллмана составим рекуррентное соотношение,
# которое называется уравнением Беллмана. Для этого рассмотрим два случая p = 1 и p ⩾ 2.

# Прямой ход динамического программирования
for p in range(P):
    for q in range(Q+1):
        if p == 0:
            B[p, q] = A[p, q] # Единственная возможность, которая имеется — это отдать весь имеющийся запас
                              # ресурса в количестве q единиц этому агенту. В результате мы получим прибыль, равную A(p, q).
            C[p, q] = q
        else:
            max_profit = -1
            for i in range(q+1):
                current_profit = A[p, i] + B[p-1, q-i] # Размер максимальной прибыли, которую получим, распределив q единиц
                                                        # ресурса между первыми p агентами, равен максимальному из (q+1) найденных
                                                        # суммарных прибылей
                if current_profit > max_profit:
                    max_profit = current_profit
                    C[p, q] = i
            B[p, q] = max_profit

# Максимальная прибыль
print("Матрица B (максимальная прибыль):")
print(B)
print("Матрица C (распределение ресурсов):")
print(C)

print('-----------------------------------------------')
print("Максимальная прибыль:", B[P-1][Q])

# Обратный ход для нахождения оптимального распределения
q = Q
p = P - 1
allocation = []

while p >= 0:
    allocation.append((p+1, C[p, q]))
    q -= C[p, q]
    p -= 1

allocation.reverse()
print("Оптимальное распределение ресурсов:")
for agent, res in allocation:
    print(f"\tАгент {agent} получает {res} единиц ресурса")
