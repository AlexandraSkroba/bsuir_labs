from collections import Counter
from copy import deepcopy

import numpy as np


def balace_cond(a, b, c):
    if (diff := sum(a) - sum(b)) > 0:
        b_new = np.append(b, diff)
        a_new = a
        c_new = np.append(c, [[0] * c.shape[0]], axis=1)
        print('Количество поставщиков больше числа потребителей, следовательно, добавим фиктивного потребителя и обновим матрицу c')
        print('Вектор поставщиков: ', a_new, sep='')
        print('Вектор потребителей: ', b_new, sep='')
        print('Матрица, содержащая значения тарифов на перевозку груза: ', c_new, sep='\n')
    elif diff < 0:
        b_new = b
        a_new = np.append(a, -diff)
        c_new = np.append(c, [[0] * c.shape[1]], axis=0)
        print('Количество потребителей больше числа поставщиков, следовательно, добавим фиктивного поставщика и обновим матрицу c\n')
        print('Вектор поставщиков: ', a_new, sep='')
        print('Вектор потребителей: ', b_new, sep='')
        print('Матрица, содержащая значения тарифов на перевозку груза: ', c_new, sep='\n')
    else:
        a_new = a
        b_new = b
        c_new = c
        print('Изменения не требуются')
    return a_new, b_new, c_new


if __name__ == "__main__":
    a = np.array([100, 300, 300])
    print('Вектор поставщиков: ', a, sep='')
    b = np.array([300, 200, 200])
    print('Вектор потребителей: ', b, sep='')
    c = np.array([[8, 4, 1],
                  [8, 4, 3],
                  [9, 7, 5]])
    print('Матрица, содержащая значения тарифов на перевозку груза: ', c, sep='\n')
    print('При несоответствии количества поставщиков количеству потребителей и наоборот выполняем балансировку')
    a, b, c = balace_cond(a, b, c)
    # Шаг 1. Метод северо-западного угла
    # План перевозок и список базисных позиций
    print('\nНаходим начальный базисный план перевозок методом северо-западного угла')
    # Нулевая матрица 3х3
    x = np.zeros((len(a), len(b)))
    # Множество базисных позиций
    B = []
    i, j = 0, 0
    # Цикл продолжается до тех пор, пока индексы i и j не выйдут за границы векторов a и b
    while i < len(a) and j < len(b):
        # Минимальное значение между текущими значениями поставщика a[i] и потребителя b[j]
        minimum = min([a[i], b[j]])
        # Записываем это минимальное значение в матрицу перевозок x на позицию (i, j)
        x[i, j] = minimum
        B.append((i, j))
        # Уменьшаем значения поставщика и потребителя на величину, которая была выделена для перевозки
        a[i] -= minimum
        b[j] -= minimum
        # Если у текущего поставщика не осталось товаров для перевозки и есть еще поставщики,
        # переходим к следующему поставщику и наоборот
        if a[i] == 0 and i < len(a) - 1:
            i += 1
        elif b[j] == 0:
            j += 1
    print('Базисный план x: ', x, sep='\n')
    print('Список координат, соответствующий непустым ячейкам в базисном плане: ', B, sep='')
    print('\nРеализация метода потенциалов')
    n, m = len(a), len(b)
    counter = 0
    while True:
        counter += 1
        print(f'----------Итерация {counter}----------')
        #матрица коэффициентов системы уравнений
        A = np.zeros((m + n, m + n))
        #вектор правых частей системы уравнений
        b = np.zeros(m + n)
        for num, (i, j) in enumerate(B):
            A[num][i] = 1
            A[num][m + j] = 1
            b[num] = c[i][j]
        A[-1][0] = 1

        # Находим u и v насколько можно изменить стоимость перевозок, не нарушая общих условий задачи
        u_v = np.linalg.solve(A, b)
        u = u_v[:m]
        v = u_v[m:]
        print('Находим потенциал u: ', u, sep='')
        print('Находим потенциал v: ', v, sep='')

        print('Проверка условий оптимальности') #т.е. минимизирует стоимость перевозок
        optimal, flag = True, True #флаг для контроля вложенных циклов
        for i in range(m):
            if flag:
                for j in range(n):
                    if u[i] + v[j] > c[i][j]:
                        optimal, flag = False, False
                        #В список базисных клеток B добавляется клетка (i, j), которая
                        # потенциально может улучшить текущий план
                        B.append((i, j))
                        print('   План не оптимален!')
                        print('   Обновляем вектор координат B: ', B, sep='')
                        break
        if optimal:
            print('   План оптимальный, задача решена')
            print('   План x: ', x, sep='\n')
            break

        print('Если в строке/столбце меньше двух базисных клеток, то выполняем операцию удаления')
        B_copy = deepcopy(B)
        while True:
            # для определения, как часто каждый индекс встречается среди базисных клеток
            i_list = [i for (i, j) in B_copy]
            j_list = [j for (i, j) in B_copy]

            #количество вхождений каждого индекса строк и столбцов соответственно
            i_counter = Counter(i_list)
            j_counter = Counter(j_list)

            #соответствующая строка или столбец содержат только одну базисную клетку,
            # что может привести к вырожденному решению (число базисных клеток меньше, чем необходимо для устойчивого решения задачи)
            i_to_rm = [i for i in i_counter if i_counter[i] == 1]
            j_to_rm = [j for j in j_counter if j_counter[j] == 1]

            #все возможные избыточные клетки удалены
            if not i_to_rm and not j_to_rm:
                break
            B_copy = [(i, j) for (i, j) in B_copy if i not in i_to_rm
                      and j not in j_to_rm]
        print('Вектор В после операции удаления: ', B_copy, sep='')

        print('Распределение клеток по + и -')
        #Эти списки помогают визуально и логически разделять клетки на те, которые будут
        # увеличивать количество перевозимых товаров, и те, которые будут уменьшать
        plus, minus = [], []
        # стартовая точка для последующего распределения
        plus.append(B_copy.pop())

        # гарантирует, что создаваемый цикл замкнут
        while B_copy:
            if len(plus) > len(minus):
                for index, (i, j) in enumerate(B_copy):
                    if plus[-1][0] == i or plus[-1][1] == j:
                        minus.append(B_copy.pop(index))
                        break
            else:
                for index, (i, j) in enumerate(B_copy):
                    if minus[-1][0] == i or minus[-1][1] == j:
                        plus.append(B_copy.pop(index))
                        break
        print('   Плюсы: ', plus, sep='')
        print('   Минусы: ', minus, sep='')

        # определить минимальное количество товара, которое можно переместить между этими клетками,
        # чтобы улучшить или корректировать транспортный план. Это делается путем вычисления
        # параметра Θ, который равен минимальному значению перевозки среди клеток в группе "-", и
        # затем корректировка перевозок вдоль цикла, определенного клетками "+" и "-" для достижения
        # оптимальности или улучшения текущего решения

        # финальная корректировка текущего транспортного плана!
        print('Обновление клеток с учетом знаков и Θ')
        # Θ определяется как минимальное значение перевозимого товара среди всех клеток в группе "minus"
        # Это значение представляет собой максимально возможное количество товара, которое можно
        # безопасно переместить вдоль цикла, сформированного клетками "+" и "-", не нарушая условий
        # задачи (то есть не допуская отрицательных значений в клетках)
        theta = min(x[i][j] for i, j in minus)
        for i, j in plus:
            x[i][j] += theta
        for i, j in minus:
            x[i][j] -= theta

        # После выполнения корректировки перевозок, проверяется каждая клетка в группе "minus" на
        # предмет того, стал ли её объём равным нулю. Если в какой-либо клетке объём перевозок становится
        # равным нулю, это означает, что данная клетка больше не является частью базиса и должна быть
        # удалена из списка базисных клеток
        for i, j in minus:
            if x[i][j] == 0:
                B.remove((i, j))
                break
        print('Обновленный план задачи: ', x, sep='\n')
        print('Обновленный вектор координат B: ', B, sep='')