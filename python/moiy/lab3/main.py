import sys
import numpy as np
from lab2 import simplex_method, get_basis_matrix

A = np.array([[1, 1, 1], [2, 2, 2]])
print(f'A={A}')
list = [[0],
        [0]]
b = np.array(list)
print(f'b={b}')
c = np.array([1, 0, 0])
print(f'c={c}')

def get_basis_plan(c, A, b):
    #1(преобразование задачи для соблюдения неотрицательности)
    # ШАГ1. Необходимо преобразовать задачу (1) таким образом, чтобы век-
    # тор правых частей b был неотрицательным. Для этого умножим на −1 все
    # ограничения задачи, правая часть которых отрицательна. А именно, для каж-
    # дого индекса i ∈ {1, 2, . . . ,m} выполним следующую операцию: если bi < 0, то
    # умножим на −1 компоненту bi и i-ю строку матрицы A;
    for index, elem in enumerate(b):
        if elem < 0:
            elem *= -1
            A[index] *= - 1

    m = A.shape[0]
    n = A.shape[1]
    print(f'm={m}')
    print(f'n={n}')

    #2(cоставим вспомогательную задачу линейного программирования)
    c_dashed = np.array([0 if i < n else -1 for i in range(n + m)])
    a_dashed = np.append(A, np.eye(2), axis=1)

    print(f'c_dashed={c_dashed}')
    print(f'a_dashed={a_dashed}')

    #3(построим начальный базисный допустимый план)
    x_dop = np.append(np.array([0 for _ in range(n)]), b)
    print(f'x_dop={x_dop}')
    B = np.array([n + i for i in range(m)])
    print(f'B={B + 1}')

    #4(решим вспомогательную задачу основной фазой симплекс-метода)
    x, B = simplex_method(c_dashed, a_dashed, x_dop, B)
    a_tran = a_dashed.transpose()
    a_basis_inv = np.linalg.inv(get_basis_matrix(a_dashed, B))

    #5(проверка условия совместности)
    # Шаг 5. Проверим условия совместности: если exn+1 = exn+2 = . . . = exn+m =
    # 0, то задача (1) совместна; в противном случае, задача (1) не совместна и метод
    # завершает свою работу.
    for i in range(m):
        if x[n + i] != 0:   #несовместна
            print("несовместна")
            sys.exit()

    #6(формируем допустимый план задачи)
    # Для него необходимо подобрать множество базисных индексов. С этой целью
    # скорректируем множество B следующим образом.
    x = x[:n]
    while True:
        #7(проверка допустимости текущего базисного плана)
        #Если B ⊆ {1, 2, . . . , n}, то метод завершает свою работу и
        # возвращает базисный допустимый план (x,B).
        basis = [j <= n for j in B]
        if all(basis):
            return x, B, A, #b + 1


        #8(находим максимальный индекс искусственной переменной)
        k = np.argmax(B)

        #9(находим векторы l для каждого индекса j от 1 до n, которого нет в В) ℓ(j) = A−1B*Aj ,
        l = {}
        for j in range(n):
            if j not in B:
                l[j] = np.dot(a_basis_inv, a_tran[j])

        #10(преобразование множества базисных индексов)
        # Если найдется индекс j ∈ {1, 2, . . . , n} \ B такой, что (ℓ(j))k ̸= 0, то
        # заменим в наборе B значение jk, равное n + i, на j.
        for j in l:
            if l[j][k] != 0:
                B[k] = j - 1

        # 11(удаление линейно зависимых ограничений)
        # Если для любого индекса j ∈ {1, 2, . . . , n} \B выполняется (ℓ(j))k =
        # 0, то i-е основное ограничение задачи (1) линейно выражается через остальные
        # и его необходимо удалить. В этом случае удалим i-ую строку из матрицы A и
        # i-ую компоненту из вектора b. Удалим из B индекс jk = n + i. Кроме этого,
        # удалим i-ую строку из матрицы e A. (в B нет индексов
        # искусственных переменных, то метод завершает свою работу.)
        for j in l:
            if l[j][k] == 0:
                A = np.delete(A, j - 1, 0)
                a_dashed = np.delete(a_dashed, j, 0)
                b = np.delete(b, j)
                B = np.delete(B, j)
                break

if __name__ == '__main__':
    for res in get_basis_plan(c, A, b):
        print(res)