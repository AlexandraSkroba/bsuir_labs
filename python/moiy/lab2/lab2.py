import numpy as np

if __name__ == '__main__':
    m = 3
    n = 5

    A = np.array([[-1, 1, 1, 0, 0],
                    [1, 0, 0, 1, 0],
                    [0, 1, 0, 0, 1]])

    det_T = -1
    i = 1
    # вектор базисных индексов. Этот вектор определяет, какие переменные входят в базис на каждой итерации симплекс-метода.
    # Базисные переменные являются переменными, которые необходимо выразить через небазисные переменные,
    # чтобы найти оптимальное решение.
    B = np.array([[3, 4, 5]])

    # вектор коэффициентов целевой функции. В контексте симплекс-метода это вектор,
    # определяющий целевую функцию, которую мы хотим минимизировать или максимизировать.
    # Каждый элемент этого вектора соответствует коэффициенту при соответствующей переменной в целевой функции.
    cT = np.array([[1, 1, 0, 0, 0]])

    # текущий оптимальный план решения обеспечивает наилучшее значение
    # целевой функции удовлетворяет всем ограничениям задачи
    xT = np.array([[0, 0, 1, 3, 2]])

    while True:
        print()
        print("Матрица A:")
        print(A)

        print(f'-----Итерация {i}-----')

        print("Вектор B:")
        print(B)

        # ШАГ1. Строим базисную матрицу AB и находим ее обратную матрицу
        AB = A[:, B.flatten() - 1]  # Выбираем столбцы матрицы A с помощью среза

        print("Матрица AB:")
        print(AB)

        det = np.linalg.det(AB)  # Вычисляем определитель
        if det != 0:  # Проверяем, что определитель не равен нулю
            AB_inv = np.linalg.inv(AB)  # Находим обратную матрицу
            print("Обратная матрица к AB:")
            print(AB_inv)
        else:
            print("Матрица AB вырождена, обратной матрицы не существует.")

        print('Вектор коэффициентов')
        print(cT)
        cB = cT[:, B.flatten() - 1]
        print("Вектор cB:")
        print(cB)

        # ШАГ3. Находим вектор потенциалов uT = cT * AB_inv
        # используется для оценки изменений значения целевой функции при увеличении/уменьшении
        # значений базисных переменных. Этот вектор помогает определить, какие переменные могут войти в базис,
        # чтобы улучшить значение целевой функции.
        uT = cB @ AB_inv
        print('Вектор потенциалов: ')
        print(uT)

        # ШАГ4. Находим вектор оценок det_T = uT * A − cT;
        # как изменится значение целевой функции при увеличении/уменьшении базисных переменных на единицу.
        # Он представляет собой разницу между текущими коэффициентами целевой функции и произведением вектора
        # потенциалов на матрицу коэффициентов ограничений.
        det_T = uT @ A - cT
        print('Вектор оценок:')
        print(det_T)

        # ШАГ5. Проверяем условие оптимальности текущего плана x,
        # если Δ ⩾ 0, то текущий x является оптимальным планом задачи и метод
        # завершает свою работу, возвращая в качестве ответа текущий x;

        # ШАГ6. Находим в векторе оценок Δ первую отрицательную компоненту и
        # ее индекс сохраним в переменной j;
        j = np.argmax(det_T < 0) #---------
        if np.any(det_T < 0):
            det_Tj = int(det_T[det_T < 0][0])
            print(f'det_Tj = {det_Tj}')
        else:
            print(f"Оптимальный план x = {xT}")
            exit()
        print(f'j = {j + 1}')

        # ШАГ7. Вычислим вектор z = A−1
        # B Aj0 , где Aj0 — столбец матрицы A с индексом j;
        # для вычисления относительной величины изменения значений переменных при увеличении/уменьшении
        # базисных переменных. Этот вектор помогает определить, как изменится значение оценок при изменении базисных переменных.
        Aj = A[:, j]
        z = AB_inv @ Aj
        print(f'Вектор z = {z}')

        # ШАГ8. Шаг 8. Находим вектор θ⊺ = (θ1, θ2, . . . , θm) ∈ Rm
        # для определения относительной величины изменения значений переменных при изменении базисных переменных.
        # Этот вектор позволяет определить, насколько можно увеличить или уменьшить значения базисных переменных до того,
        # как какая-либо переменная станет небазисной, и значение целевой функции перестанет улучшаться.
        tet_T = []
        for q, z_vector in enumerate(z):
            if z_vector <= 0:
                tet_T.append(np.inf)
            else:
                tet_T.append(xT[0, (B[0, q] - 1)] / z[q])

        print(f'θ⊺ = {tet_T}')

        # ШАГ9. Находим индекс минимального элемента вектора tet_T
        tet_min = np.min(tet_T)
        print(f'np.min(tet_T) = {np.min(tet_T)}')

        # ШАГ10. Проверяем условие неограниченности целевого функционала: если θ0 = ∞
        if(tet_min == np.inf):
            print('целевой функционал задачи (1) не ограничен сверху на множестве допустимых планов')
            exit()

        # ШАГ11. Находим первый индекс k, на котором достигается минимум,
        # и сохраним в переменной j∗ k-й базисный индекс из B;
        k = np.argmin(tet_T) + 1

        # Находим индекс j* по формуле
        j_star = B[0, k - 1]
        print(f'k = {k}, j* = {j_star}')

        # ШАГ12. Обновляем базисные индексы в упорядоченном множестве В заменяем
        # k-й индекс j_star на индекс j0
        B[0, k - 1] = j + 1
        print("Обновленный вектор B:")
        print(B)
        print(xT)

        # ШАГ13. Обновляем компоненты текущего плана x
        xT[0, i - 1] = tet_min  # xj0 = θ0
        if k == 1:
            xT[0, (B[0, 1] - 1)] -= tet_min * z[1]
            xT[0, (B[0, 2] - 1)] -= tet_min * z[2]
        if k == 2:
            xT[0, (B[0, 0] - 1)] -= tet_min * z[0]
            xT[0, (B[0, 2] - 1)] -= tet_min * z[2]
        if k == 3:
            xT[0, (B[0, 0] - 1)] -= tet_min * z[0]
            xT[0, (B[0, 1] - 1)] -= tet_min * z[1]
        xT[0, j_star - 1] = 0

        print("Обновленный вектор x:")
        print(xT)

        i += 1
        