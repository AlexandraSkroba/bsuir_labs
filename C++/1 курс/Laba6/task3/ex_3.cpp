// Лабораторная 6, задача 3(вариант 10). Выполнена: Скроба А.П.

/* Ввести массив строк. В функции для каждой строки проверить, является она 
палиндромом (симметричной с точностью до пробелов) или нет. Например, 
палиндромами являются цепочки: «АРГЕНТИНА МАНИТ НЕ ГРА» и «А РОЗА УПАЛА НА ЛАПУ АЗОРА».*/

#include <iostream>

int removing_spaces(int startSize, char* str_1, char* str) {
    int j = 0; //счетчик для цикла str_1
    for (int i = 0; i < startSize; i++){ //цикл "бежит" по считанному массиву (str) и переписывает символы в новый массив (str_1), при этом пробелы пропускает, а если доберется до точки, то записывает терминальный ноль и выходит из цикла
        if (str[i] == ' ') continue;
        if (str[i] == '.')
        {
            str_1[j] = '\0';
            break;
        }
        str_1[j] = str[i];
        j++;
    }
    return *str_1;
}

int main() {
    setlocale(LC_ALL, "rus");

    const int startSize = 256; //ограничиваем размер массива
    char str[startSize];
    std::cout << "Программа проверяет является ли строка палиндромом (симметричной с точностью до пробелов) или нет.\nВведите строку: ";
    std::cin.getline(str, '.'); //считываем строку до точки
    char str_1[startSize]; //создаем дополнительный массив, который будет хранить все символы слитно (и без точки на конце)

    removing_spaces(startSize, str_1, str);

    const int resSize = strlen(str_1); //размер второго вспомогательного массива str_2
    char* str_2 = new char[resSize + 1]; //динамически создаем второй массив
    for (int i = 0; i < resSize; i++) { //переписывает массив str_1 только наоборот в массив str_2
        str_2[i] = str_1[resSize - 1 - i];
    }
    str_2[resSize] = '\0'; //в последний элемент кладем терминальный ноль

    if (!strcmp(str_1, str_2)) std::cout << "Строка является палиндромом\n"; //функция strcmp() сравнивает два массива
    else std::cout << "Строка НЕ является палиндромом\n";
    delete[] str_2; 
    return 0;
}